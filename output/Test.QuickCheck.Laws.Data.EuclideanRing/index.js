// Generated by purs version 0.15.4
import * as Control_Apply from "../Control.Apply/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Semiring from "../Data.Semiring/index.js";
import * as Effect_Console from "../Effect.Console/index.js";
import * as Test_QuickCheck from "../Test.QuickCheck/index.js";
import * as Test_QuickCheck_Arbitrary from "../Test.QuickCheck.Arbitrary/index.js";
import * as Test_QuickCheck_Gen from "../Test.QuickCheck.Gen/index.js";
var quickCheck$prime = /* #__PURE__ */ Test_QuickCheck["quickCheck$prime"](/* #__PURE__ */ Test_QuickCheck.testableFunction(Test_QuickCheck_Arbitrary.arbUnit)(Test_QuickCheck.testableBoolean));
var quickCheck$prime1 = /* #__PURE__ */ Test_QuickCheck["quickCheck$prime"](/* #__PURE__ */ Test_QuickCheck.testableGen(Test_QuickCheck.testableBoolean));
var lift2 = /* #__PURE__ */ Control_Apply.lift2(Test_QuickCheck_Gen.applyGen);
var map = /* #__PURE__ */ Data_Functor.map(Test_QuickCheck_Gen.functorGen);
var checkEuclideanRingGen = function (dictEuclideanRing) {
    var Semiring0 = ((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0();
    var zero1 = Data_Semiring.zero(Semiring0);
    var degree = Data_EuclideanRing.degree(dictEuclideanRing);
    var mul = Data_Semiring.mul(Semiring0);
    var mod = Data_EuclideanRing.mod(dictEuclideanRing);
    var div = Data_EuclideanRing.div(dictEuclideanRing);
    var add = Data_Semiring.add(Semiring0);
    var one = Data_Semiring.one(Semiring0);
    return function (dictEq) {
        var eq = Data_Eq.eq(dictEq);
        var notEq = Data_Eq.notEq(dictEq);
        return function (gen) {
            var submultiplicative = function (a) {
                return function (b) {
                    if (eq(a)(zero1) || eq(b)(zero1)) {
                        return true;
                    };
                    if (Data_Boolean.otherwise) {
                        return degree(a) <= degree(mul(a)(b));
                    };
                    throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 76, column 3 - line 76, column 38): " + [ a.constructor.name, b.constructor.name ]);
                };
            };
            var quotRem = function (a) {
                return function (b) {
                    if (notEq(b)(zero1)) {
                        var r = mod(a)(b);
                        var q = div(a)(b);
                        return eq(a)(add(mul(q)(b))(r)) && (eq(r)(zero1) || degree(r) < degree(b));
                    };
                    if (Data_Boolean.otherwise) {
                        return true;
                    };
                    throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 65, column 3 - line 65, column 28): " + [ a.constructor.name, b.constructor.name ]);
                };
            };
            var nonnegativeEuclideanFunc = function (a) {
                if (notEq(a)(zero1)) {
                    return degree(a) >= 0;
                };
                if (Data_Boolean.otherwise) {
                    return true;
                };
                throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 60, column 3 - line 60, column 41): " + [ a.constructor.name ]);
            };
            var integralDomain = function (a) {
                return function (b) {
                    if (notEq(a)(zero1) && notEq(b)(zero1)) {
                        return notEq(mul(a)(b))(zero1);
                    };
                    if (Data_Boolean.otherwise) {
                        return true;
                    };
                    throw new Error("Failed pattern match at Test.QuickCheck.Laws.Data.EuclideanRing (line 55, column 3 - line 55, column 35): " + [ a.constructor.name, b.constructor.name ]);
                };
            };
            return function __do() {
                Effect_Console.log("Checking 'Integral domain' law for EuclideanRing")();
                Effect_Console.log("one /= zero:")();
                quickCheck$prime(1)(function (v) {
                    return notEq(zero1)(one);
                })();
                Effect_Console.log("product of nonzero elements is nonzero:")();
                quickCheck$prime1(1000)(lift2(integralDomain)(gen)(gen))();
                Effect_Console.log("Checking 'Nonnegative euclidean function' law for EuclideanRing")();
                quickCheck$prime1(1000)(map(nonnegativeEuclideanFunc)(gen))();
                Effect_Console.log("Checking 'Quotient/remainder' law for EuclideanRing")();
                quickCheck$prime1(1000)(lift2(quotRem)(gen)(gen))();
                Effect_Console.log("Checking 'Submultiplicative euclidean function' law for EuclideanRing")();
                return quickCheck$prime1(1000)(lift2(submultiplicative)(gen)(gen))();
            };
        };
    };
};
var checkEuclideanRing = function (dictEuclideanRing) {
    var checkEuclideanRingGen1 = checkEuclideanRingGen(dictEuclideanRing);
    return function (dictArbitrary) {
        var arbitrary = Test_QuickCheck_Arbitrary.arbitrary(dictArbitrary);
        return function (dictEq) {
            var checkEuclideanRingGen2 = checkEuclideanRingGen1(dictEq);
            return function (v) {
                return checkEuclideanRingGen2(arbitrary);
            };
        };
    };
};
export {
    checkEuclideanRing,
    checkEuclideanRingGen
};
