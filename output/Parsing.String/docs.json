{"comments":"Primitive parsers for working with an input stream of type `String`.\n\nAll of these primitive parsers will consume when they succeed.\n\nAll of these primitive parsers will not consume when they\nfail.\n\nThe behavior of these primitive parsers is based on the behavior of the\n`Data.String` module in the __strings__ package.\nIn most JavaScript runtime environments, the `String`\nis little-endian [UTF-16](https://en.wikipedia.org/wiki/UTF-16).\n\nThe primitive parsers which return `Char` will only succeed when the character\nbeing parsed is a code point in the\n[Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane)\n(the “BMP”). These parsers can be convenient because of the good support\nthat PureScript has for writing `Char` literals like `'あ'`, `'β'`, `'C'`.\n\nThe other primitive parsers, which return `CodePoint` and `String` types,\ncan parse the full Unicode character set. All of the primitive parsers\nin this module can be used together.\n\n### Position\n\nIn a `String` parser, the `Position {index}` counts the number of\nunicode `CodePoint`s since the beginning of the input string.\n\nEach tab character (`0x09`) encountered in a `String` parser will advance\nthe `Position {column}` by 8.\n\nThese patterns will advance the `Position {line}` by 1 and reset\nthe `Position {column}` to 1:\n- newline (`0x0A`)\n- carriage-return (`0x0D`)\n- carriage-return-newline (`0x0D 0x0A`)\n","declarations":[{"children":[],"comments":"Match the specified BMP `Char`.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Char"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"Char"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[142,48],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[142,1]},"title":"char"},{"children":[],"comments":"Match the specified string.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[87,54],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[87,1]},"title":"string"},{"children":[],"comments":"Match any BMP `Char`.\nParser will fail if the character is not in the Basic Multilingual Plane.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"Char"],"tag":"TypeConstructor"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[97,43],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[97,1]},"title":"anyChar"},{"children":[],"comments":"Match any Unicode character.\nAlways succeeds when any input remains.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Data","String","CodePoints"],"CodePoint"],"tag":"TypeConstructor"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[102,53],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[102,1]},"title":"anyCodePoint"},{"children":[],"comments":"Match a BMP `Char` satisfying the predicate.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Char"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"Boolean"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"Char"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[106,64],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[106,1]},"title":"satisfy"},{"children":[],"comments":"Match a Unicode character satisfying the predicate.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","String","CodePoints"],"CodePoint"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"Boolean"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Data","String","CodePoints"],"CodePoint"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[128,83],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[128,1]},"title":"satisfyCodePoint"},{"children":[],"comments":"Match a `String` exactly *N* characters long.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[146,50],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[146,1]},"title":"takeN"},{"children":[],"comments":"Match the entire rest of the input stream. Always succeeds.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[82,42],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[82,1]},"title":"rest"},{"children":[],"comments":"Match “end-of-file,” the end of the input stream.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Data","Unit"],"Unit"],"tag":"TypeConstructor"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[71,39],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[71,1]},"title":"eof"},{"children":[],"comments":"Combinator which returns both the result of a parse and the slice of\nthe input that was consumed while it was being parsed.\n\nBecause `String`s are not `Char` arrays in PureScript, `many` and `some`\non `Char` parsers need to\nbe used with `Data.String.CodeUnits.fromCharArray` to\nconstruct a `String`.\n\n```\nfromCharArray <$> Data.Array.many (char 'x')\n```\n\nIt’s more efficient to achieve the same result by using this `match` combinator\ninstead of `fromCharArray`.\n\n```\nfst <$> match (Combinators.skipMany (char 'x'))\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":["a",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple"],"Tuple"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[195,77],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[195,1]},"title":"match"},{"children":[],"comments":"Compile a regular expression `String` into a regular expression parser.\n\nThis function will use the `Data.String.Regex.regex` function to compile\nand return a parser which can be used\nin a `ParserT String m` monad.\nIf compilation fails then this function will return `Left` a compilation\nerror message.\n\nThe returned parser will try to match the regular expression pattern once,\nstarting at the current parser position. On success, it will return\nthe matched substring.\n\nIf the RegExp `String` is constant then we can assume that compilation will\nalways succeed and `unsafeCrashWith` if it doesn’t. If we dynamically\ngenerate the RegExp `String` at runtime then we should handle the\ncase where compilation of the RegExp fails.\n\nThis function should be called outside the context of a `ParserT String m`\nmonad for two reasons:\n1. If we call this function inside of the `ParserT String m` monad and\n   then `fail` the parse when the compilation fails,\n   then that could be confusing because a parser failure is supposed to\n   indicate an invalid input string.\n   If the compilation failure occurs in an `alt` then the compilation\n   failure might not be reported at all and instead\n   the input string would be parsed incorrectly.\n2. Compiling a RegExp is expensive and it’s better to do it\n   once in advance and then use the compiled RegExp many times than\n   to compile the RegExp many times during the parse.\n\nThis parser may be useful for quickly consuming a large section of the\ninput `String`, because in a JavaScript runtime environment a compiled\nRegExp is a lot faster than a monadic parser built from parsing primitives.\n\n[*MDN Regular Expressions Cheatsheet*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet)\n\n#### Example\n\nThis example shows how to compile and run the `xMany` parser which will\ncapture the regular expression pattern `x*`.\n\n```purescript\ncase regex \"x*\" noFlags of\n  Left compileError -> unsafeCrashWith $ \"xMany failed to compile: \" <> compileError\n  Right xMany -> runParser \"xxxZ\" do\n    xMany\n```\n\n#### Flags\n\nSet `RegexFlags` with the `Semigroup` instance like this.\n\n```purescript\nregex \"x*\" (dotAll <> ignoreCase)\n```\n\nThe `dotAll`, `unicode`, and `ignoreCase` flags might make sense for\na `regex` parser. The other flags will\nprobably cause surprising behavior and you should avoid them.\n\n[*MDN Advanced searching with flags*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags)\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Data","String","Regex","Flags"],"RegexFlags"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Either"],"Either"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[268,83],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[268,1]},"title":"regex"},{"children":[],"comments":"Combinator which finds the first position in the input `String` where the\nphrase can parse. Returns both the\nparsed result and the unparsable input section searched before the parse.\nWill fail if no section of the input is parseable. To backtrack the input\nstream on failure, combine with `tryRethrow`.\n\nThis combinator works like\n[Data.String.takeWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:takeWhile)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search)\nand it allows using a parser for the pattern search.\n\nThis combinator is equivalent to `manyTill_ anyCodePoint`, but it will be\nfaster because it returns a slice of the input `String` for the\nsection preceding the parse instead of a `List CodePoint`.\n\nBe careful not to look too far\nahead; if the phrase parser looks to the end of the input then `anyTill`\ncould be *O(n²)*.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":["a",{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad"],"Monad"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple"],"Tuple"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},null],"tag":"ForAll"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[327,39],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[323,1]},"title":"anyTill"},{"children":[],"comments":"Consume a portion of the input string while yielding a value.\n\nTakes a consumption function which takes the remaining input `String`\nas its argument and returns either an error message, or three fields:\n\n* `value` is the value to return.\n* `consumed` is the input `String` that was consumed. It is used to update the parser position.\n  If the `consumed` `String` is non-empty then the `consumed` flag will\n  be set to true. (Confusing terminology.)\n* `remainder` is the new remaining input `String`.\n\nThis function is used internally to construct primitive `String` parsers.\n","info":{"declType":"value","type":{"annotation":[],"contents":["m",{"annotation":[],"contents":["a",{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Either"],"Either"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Record"],"tag":"TypeConstructor"},{"annotation":[],"contents":["value",{"annotation":[],"contents":"a","tag":"TypeVar"},{"annotation":[],"contents":["consumed",{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"},{"annotation":[],"contents":["remainder",{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"},{"annotation":[],"tag":"REmpty"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},null],"tag":"ForAll"},null],"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[294,24],"name":".spago/parsing/v10.0.0/src/Parsing/String.purs","start":[291,1]},"title":"consumeWith"}],"name":"Parsing.String","reExports":[]}